/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin

#if !defined(-->prefixCOCO_PARSER_H__)
#define -->prefixCOCO_PARSER_H__

-->headerdef

#include <string>
#include "Scanner.h"

-->namespace_open


class Errors {
public:
	int count;			// number of errors detected

	Errors() {
		count = 0;
	}

	void SynErr(int line, int col, int n) {
		std::wstring s;
		switch (n) {
-->errors
			default:
			{
				std::wstringstream ss;
				ss << "error " << n;
				s = ss.str();
			}
			break;
		}
		fwprintf(stderr, L"-- line %d col %d: %ls\n", line, col, s.c_str());
		CocoUtil::coco_string_delete(s);
		count++;
	}

	void Error(int line, int col, const std::wstring s) {
		fwprintf(stderr, L"-- line %d col %d: %ls\n", line, col, s.c_str());
		count++;
	}

	void Warning(int line, int col, const std::wstring s) {
		fwprintf(stderr, L"-- line %d col %d: %ls\n", line, col, s.c_str());
	}

	void Warning(const std::wstring s) {
		fwprintf(stderr, L"%ls\n", s.c_str());
	}

	void Exception(const std::wstring s) {
		fwprintf(stderr, L"%ls", s.c_str()); 
		exit(1);
	}
						

}; // Errors


class Parser {
private:
-->constantsheader
	std::shared_ptr<Token> dummyToken;
	int errDist;
	int minErrDist;
	int maxT;


	void SynErr(int n) {
		if (errDist >= minErrDist) errors->SynErr(la->line, la->col, n);
		errDist = 0;
	}


	void Get() {
		for (;;) {
			t = la;
			la = scanner->Scan();
			if (la->kind <= maxT) { ++errDist; break; }
	-->pragmas
			if (dummyToken != t) {
				dummyToken->kind = t->kind;
				dummyToken->pos = t->pos;
				dummyToken->col = t->col;
				dummyToken->line = t->line;
				dummyToken->next = NULL;
				dummyToken->val = t->val;
				t = dummyToken;
			}
			la = t;
		}
	}

	void Expect(int n) {
		if (la->kind==n) Get(); else { SynErr(n); }
	}

	void ExpectWeak(int n, int follow) {
		if (la->kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}

	bool WeakSeparator(int n, int syFol, int repFol) {
		if (la->kind == n) {Get(); return true;}
		else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
				Get();
			}
			return StartOf(syFol);
		}
	}


	-->productions

public:

	std::shared_ptr<Scanner> scanner;
	std::shared_ptr<Errors>  errors;

	std::shared_ptr<Token> t;			// last recognized token
	std::shared_ptr<Token> la;			// lookahead token

-->declarations

	// If the user declared a method Init and a mehtod Destroy they should
	// be called in the contructur and the destructor respctively.
	//
	// The following templates are used to recognize if the user declared
	// the methods Init and Destroy.

	template<typename T>
	struct ParserInitExistsRecognizer {
		template<typename U, void (U::*)() = &U::Init>
		struct ExistsIfInitIsDefinedMarker{};

		struct InitIsMissingType {
			char dummy1;
		};
		
		struct InitExistsType {
			char dummy1; char dummy2;
		};

		// exists always
		template<typename U>
		static InitIsMissingType is_here(...);

		// exist only if ExistsIfInitIsDefinedMarker is defined
		template<typename U>
		static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

		enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
	};

	template<typename T>
	struct ParserDestroyExistsRecognizer {
		template<typename U, void (U::*)() = &U::Destroy>
		struct ExistsIfDestroyIsDefinedMarker{};

		struct DestroyIsMissingType {
			char dummy1;
		};
		
		struct DestroyExistsType {
			char dummy1; char dummy2;
		};

		// exists always
		template<typename U>
		static DestroyIsMissingType is_here(...);

		// exist only if ExistsIfDestroyIsDefinedMarker is defined
		template<typename U>
		static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

		enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
	};

	// The folloing templates are used to call the Init and Destroy methods if they exist.

	// Generic case of the ParserInitCaller, gets used if the Init method is missing
	template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
	struct ParserInitCaller {
		static void CallInit(T *t) {
			// nothing to do
		}
	};

	// True case of the ParserInitCaller, gets used if the Init method exists
	template<typename T>
	struct ParserInitCaller<T, true> {
		static void CallInit(T *t) {
			t->Init();
		}
	};

	// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
	template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
	struct ParserDestroyCaller {
		static void CallDestroy(T *t) {
			// nothing to do
		}
	};

	// True case of the ParserDestroyCaller, gets used if the Destroy method exists
	template<typename T>
	struct ParserDestroyCaller<T, true> {
		static void CallDestroy(T *t) {
			t->Destroy();
		}
	};

	void Parse() {
		t = NULL;
		la = dummyToken = std::shared_ptr<Token>(new Token());
		la->val = CocoUtil::coco_string_create(L"Dummy Token");
		Get();
	-->parseRoot
	}

	Parser(std::shared_ptr<Scanner> scanner) {
	-->constants
		ParserInitCaller<Parser>::CallInit(this);
		dummyToken = NULL;
		t = la = NULL;
		minErrDist = 2;
		errDist = minErrDist;
		this->scanner = scanner;
		errors = std::shared_ptr<Errors>(new Errors());
	}


	~Parser() {
		ParserDestroyCaller<Parser>::CallDestroy(this);
	}

	void SemErr(const std::wstring msg) {
		if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
		errDist = 0;
	}

private:

	bool StartOf(int s) {
		const bool T = true;
		const bool x = false;

	-->initialization

		return set[s][la->kind];
	}


}; // end Parser




-->namespace_close

#endif

-->endParser
